from __future__ import annotations
# meta programming  

from typing import List, Union

__all__ = ['Loss', 'AbstractLossNode', 'writeCode']

class AbstractLossNode:
    def __init__(
        self, name, children: List[Union[AbstractLossNode, str]], 
    ) -> None:
        self.name = name
        self.children = children

        self.class_name = 'Loss_' + name

class Loss:
    ...

def writeCode(file, root: AbstractLossNode):
    def p(*a, indent=0, **kw):
        print(' ' * (indent * 4), end='', file=file)
        print(*a, file=file, **kw)
    p('from __future__ import annotations')
    module_name = 'loss_tree' if __name__ == '__main__' else __name__
    p(f'# Auto generated by torchWork.{module_name} . Do not modify!')
    p()
    p(f'from torchWork import Loss')
    p()
    dfs(p, root)

def dfs(p, node: AbstractLossNode):
    p(f'class {node.class_name}(Loss):')
    p('def __init__(self):', indent=1)
    for child in node.children:
        if isinstance(child, AbstractLossNode):
            p('self.%s: %s = %s()' % (
                child.name, child.class_name, child.class_name, 
            ), indent=2)
        else:
            p('self.%s: float = None' % child, indent=2)
    p()
    for child in node.children:
        if isinstance(child, AbstractLossNode):
            dfs(p, child)

def demo():
    with open('losses.py', 'w') as f:
        writeCode(f, AbstractLossNode('total', [
            AbstractLossNode('vae', ['reconstruct', 'kld']), 
            AbstractLossNode('vrnn', [
                AbstractLossNode('predict', ['z', 'image']), 
                'kld', 
            ]), 
            'weight_decay',
        ]))

if __name__ == '__main__':
    demo()
